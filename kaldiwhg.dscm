(cond-expand (debug
(define-syntax debug
  (syntax-rules () ; flush-output-port below: optional for better debugging
    ((debug f a1)
     (when (memv f (debug-flags)) ; numbers may not work with memq
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (newline p)
         (flush-output-port p)
         )))
    ((debug f a1 a2)
     (when (memv f (debug-flags))
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (display a2 p)
         (newline p)
         (flush-output-port p)
         )))
    ((debug f a1 a2 a3)
     (when (memv f (debug-flags))
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (display a2 p)
         (display a3 p)
         (newline p)
         (flush-output-port p)
         )))
    ((debug f a1 a2 a3 a4)
     (when (memv f (debug-flags))
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (display a2 p)
         (display a3 p)
         (display a4 p)
         (newline p)
         (flush-output-port p)
         )))
    ((debug f a1 a2 a3 a4 a5)
     (when (memv f (debug-flags))
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (display a2 p)
         (display a3 p)
         (display a4 p)
         (display a5 p)
         (newline p)
         (flush-output-port p)
         )))
    ((debug f a1 a2 a3 a4 a5 a6)
     (when (memv f (debug-flags))
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (display a2 p)
         (display a3 p)
         (display a4 p)
         (display a5 p)
         (display a6 p)
         (newline p)
         (flush-output-port p)
         )))
    ((debug f a1 a2 a3 a4 a5 a6 a7)
     (when (memv f (debug-flags))
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (display a2 p)
         (display a3 p)
         (display a4 p)
         (display a5 p)
         (display a6 p)
         (display a7 p)
         (newline p)
         (flush-output-port p)
         )))
    ((debug f a1 a2 a3 a4 a5 a6 a7 a8)
     (when (memv f (debug-flags))
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (display a2 p)
         (display a3 p)
         (display a4 p)
         (display a5 p)
         (display a6 p)
         (display a7 p)
         (display a8 p)
         (newline p)
         (flush-output-port p)
         )))
    ((debug f a1 a2 a3 a4 a5 a6 a7 a8 a9)
     (when (memv f (debug-flags))
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (display a2 p)
         (display a3 p)
         (display a4 p)
         (display a5 p)
         (display a6 p)
         (display a7 p)
         (display a8 p)
         (display a9 p)
         (newline p)
         (flush-output-port p)
         )))
    ((debug f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
     (when (memv f (debug-flags))
       (let ((p (or *debug-port (current-output-port))))
         (display a1 p)
         (display a2 p)
         (display a3 p)
         (display a4 p)
         (display a5 p)
         (display a6 p)
         (display a7 p)
         (display a8 p)
         (display a9 p)
         (display a10 p)
         (newline p)
         (flush-output-port p)
         )))
    ))
)(else ; cond-expand
(define-syntax debug
  (syntax-rules
    ()
    ((debug f . l)
     #t))) ; value required (instead of (begin)) by vicare, 2011-11-11
))
(cond-expand (debug
(define-syntax debugging?
  (syntax-rules
    ()
    ((debugging? f)
     (option? (debug-flags) f))))
)(else ; cond-expand
(define-syntax debugging?
  (syntax-rules
    ()
    ((debugging? f)
     #f)))
))
(cond-expand (bigloo-disabled ; this uses built-in functions, same speed, hence disabled
(define-syntax map-if
  (syntax-rules ()
    ((map-if pred l)
     (filter-map pred l))
    ((map-if pred l1 l2)
     (filter-map pred l1 l2))
    ))) ; bigloo's implementation is guaranteed to work from left to right
(else
(define-syntax map-if
  (syntax-rules ()
    ((map-if pred l)
     (map-if-1 pred l))
    ((map-if pred l1 l2)
     (map-if-2 pred l1 l2))
    ((map-if pred l1 l2 l3 . more-lists)
     (module-error "general" "map-if supports max. 2 lists, got: " (list l1 l2 l3 . more-lists)))))
))
(define-syntax wr/n
  (syntax-rules ()
    ((wr/n)
     (wr #\newline))
    ((wr/n x1)
     (wr x1 #\newline))
    ((wr/n x1 x2)
     (wr x1 x2 #\newline))
    ((wr/n x1 x2 x3)
     (wr x1 x2 x3 #\newline))
    ((wr/n x1 x2 x3 x4)
     (wr x1 x2 x3 x4 #\newline))
    ((wr/n x1 x2 x3 x4 x5)
     (wr x1 x2 x3 x4 x5 #\newline))
    ((wr/n x1 x2 x3 x4 x5 x6)
     (wr x1 x2 x3 x4 x5 x6 #\newline))
    ((wr/n x1 x2 x3 x4 x5 x6 x7)
     (wr x1 x2 x3 x4 x5 x6 x7 #\newline))
    ((wr/n x1 x2 x3 x4 x5 x6 x7 x8)
     (wr x1 x2 x3 x4 x5 x6 x7 x8 #\newline))
    ((wr/n x1 x2 x3 x4 x5 x6 x7 x8 x9)
     (wr x1 x2 x3 x4 x5 x6 x7 x8 x9 #\newline))
    ((wr/n x1 x2 x3 x4 x5 x6 x7 x8 x9 x10)
     (wr x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 #\newline))
    ((wr/n x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)
     (wr x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 #\newline))
    ((wr/n x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12)
     (wr x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 #\newline))
    ((wr/n x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13)
     (wr x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 #\newline))
    ((wr/n x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14)
     (wr x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 #\newline))
    ))

;)(else)) ; cond-expand
(cond-expand (chicken
(define list-ref-check list-ref2) ; 2 or 3
  ;(debug 3 "list-ref-check: pos: " pos " l: " l)
)
(gauche
(define (list-ref-check l pos)
  (list-ref l pos #f))
)
(else
(define (list-ref-check l pos) ; iterative named-let version; avoids disadvantage of the recursive version below, shows same speed (bigloo, 20200510)
  (let iter ()
    (if (pair? l) ; don't assume that l is a list
        (cond ((= pos 0)
               (car l))
          (else
            (set! l (cdr l))
            (set! pos (- pos 1))
            (iter)))
        #f)))
;(define (list-ref-check l pos) ; recursive version, not detected as tail-recursive in bigloo
;  (if (pair? l) ; don't assume that l is a list
;    (if (= pos 0)
;      (car l)
;      (list-ref-check (cdr l) (- pos 1)))
;    #f))
))
(define (map-if-1 pred l)
  (let loop ((l2 l)
             (result '()))
    (if (null? l2)
      (reverse! result)
      (let ((x (pred (car l2))))
        (if x
          (loop (cdr l2) (cons x result))
          (loop (cdr l2) result))))))
  
(define (map-if-2 pred l m)
  (let loop ((l2 l)
             (m2 m)
             (result '()))
    (if (null? l2)
      (reverse! result)
      (let ((x (pred (car l2) (car m2))))
        (if x
          (loop (cdr l2) (cdr m2) (cons x result))
          (loop (cdr l2) (cdr m2) result))))))

(define (assoc-value l k)
  (and-let* ((info (assoc k l)))
    (cadr info)))

(define char-compare (lambda (a b)
  (let ((d (- (char->ascii a) (char->ascii b))))
    (if (< d 0)
        'less
        (if (> d 0)
            'greater
            'equal)))))

(define (combine-compare4 comp1 comp2 comp3 comp4)
  (lambda (x y)
    (let ((result1 (comp1 x y)))
      (if (eq? result1 'equal)
          (let ((result2 (comp2 x y)))
            (if (eq? result2 'equal)
                (let ((result3 (comp3 x y)))
                  (if (eq? result3 'equal)
                      (comp4 x y)
                      result3))
                result2))
          result1))))

(define (debug-on . options)
  (when (null? options)
    (set! options '(1 2 3)))
  (apply option-on! *debug-flags options)
  *debug-flags)

(define (digit->upper-char d)
  (if (< d 10)
    (ascii->char (+ d 48 )) ; 48 = (char->ascii #\0)
    (ascii->char (+ d 55)))) ; 55 = (char->ascii #\A) - 10

(define (display-p argument . port)
  (cond ((null? port)
         (display-p1 argument))
        (else
         (display-p2 argument (car port)))))

(define (display-p1 x)
  (cond ((symbol? x)
         (wr-symbol x))
        ((pair? x)
         (write-char #\()
         (display-p1-list-elements x)
         (write-char #\)))
        ;((null? x) ; once needed for Gambit (otherwise will print as empty)
        ; (write-char ()))
        (else
         (display x))))

(define (display-p1-list-elements l)
  (when (pair? l)
    (display-p1 (car l))
    (let iter ((l2 (cdr l)))
      (unless (null? l2)
        (write-char #\space)
        (cond ((pair? l2)
               (display-p1 (car l2))
               (iter (cdr l2)))
          (else ; dotted pair
            (write-char #\.)
            (write-char #\space)
            (display-p1 l2)))))))

(define (display-p2 x port)
  ;(debug 3 "display-p2: x: " x)
  (cond ((symbol? x)
         (wr-symbol-stream x port))
        ((pair? x)
         (write-char #\( port)
         (display-p2-list-elements x port)
         (write-char #\) port))
        (else
          ;(debug 3 "display-p2: else case: port: " port)
          (display x port))))

(define (display-p2-list-elements l stream)
  (cond ((pair? l)
         (display-p2 (car l) stream)
         (let ((l2 (cdr l)))
           (cond ((not (null? l2))
                  (write-char #\space stream)
                  (cond ((pair? l2)
                         (display-p2-list-elements l2 stream))
                        (else ; dotted pair
                          (write-char #\. stream)
                          (write-char #\space stream)
                          (display-p2 l2 stream)))))))))

(define (do-n p n)
  (cond ((> n 0)
         (do ((i n (- i 1)))
             ((= i 1) (p))
           (p)))))

(define (exp-base base exponent)
  (if (integer? exponent)
      (let iter ((expon exponent)
                 (result 1))
        (if (> expon 0)
            (iter (- expon 1) (* result base))
            result))
      (exp (* exponent (log base)))))

(define (extremum function compare l)
  (and (pair? l)
       (let iter ((ex (function (car l)))
                  (l2 (cdr l)))
         (if (null? l2)
           ex
           (let ((function-result (function (car l2))))
             (if (compare function-result ex)
               (iter function-result (cdr l2))
               (iter ex (cdr l2))))))))

(define (filter-new closure l)
  (let loop ((l2 l)
             (result '()))
    (if (null? l2)
      (reverse! result)
      (let ((element (car l2)))
        (if (closure element)
          (loop (cdr l2) (cons element result))
          (loop (cdr l2) result))))))

(define (for-each-rest pred l)
  (when (pair? l)
    (let loop ((x (car l))
               (l1 (cdr l)))
      (pred x l1)
      (when (pair? l1)
        (loop (car l1) (cdr l1))))))

(define (for-integers-down pred a b)
  (do ((i b (- i 1)))
      ((< i a))
    (pred i)))

(define (g-compare a b)
  (cond ((number? a)
         (if (number? b)
           (number-compare a b)
           'less))
        ((symbol? a)
         (cond ((symbol? b)
                (symbol-compare a b))
               ((number? b)
                'greater)
               (else
                 'less)))
        ((string? a)
         (cond ((string? b)
                (string-compare a b))
               ((or (number? b)
                    (symbol? b))
                'greater)
               (else
                 'less)))
        ((char? a)
         (cond ((char? b)
                (char-compare a b))
               ((or (number? b)
                    (symbol? b)
                    (string? b))
                'greater)
               (else
                 'less)))
        ((pair? a)
         (if (pair? b)
           (let ((result2 (g-compare (car a) (car b))))
             (if (eq? result2 'equal)
               (g-compare (cdr a) (cdr b))
               result2))
           'greater))
        ((null? a)
         (if (null? b)
           'equal
           (if (pair? b)
             'less
             'greater)))
        ((eqv? a #t)
         (if (eqv? b #t)
           'equal
           (if (eqv? b #f)
             'greater
             (module-error "general" "g-compare: unknown case: " a b))))
        ((eqv? a #f)
         (if (eqv? b #f)
           'equal
           (if (eqv? b #t)
             'less
             (module-error "general" "g-compare: unknown case: " a b))))
        (else
          (module-error "general" "g-compare: unknown case: " a b)))) ; was: module-warning

(define (integer->string-pad n size . pad)
  ;(debug 3 "integer->string-pad: n: " n " size: " size)
  (let* ((pad-char (if (pair? pad)
                     (car pad)
                     #\space))
         (s (make-string size pad-char)))
    (cond ((= n 0)
           (string-set! s (- size 1) #\0)
           s)
          (else
            (do ((pos (- size 1) (- pos 1)))
              ((or (= n 0)
                   (< pos 0))
               s)
              (string-set! s pos (digit->upper-char (modulo n 10)))
              (set! n (quotient n 10)))))))

(define (list->mset compare l)
  (let ((l2 (map! (lambda (x)
                    (list x 1))
                  (list-sort compare l))))
    ;(when (debugging? 3)
    ;  (debug 3 "list->mset: l2: #: " (length l2))
    ;  (write-terms (current-output-port) l2))
    (list-compress!
      (lambda (x y)
        (eq? (compare (car x) (car y)) 'equal))
      (lambda (x y)
        (list-modify! x 1 (lambda (freq)
                            (+ freq (second y))))
        x)
      l2)))

(define (list-compare-n compare l1 l2 n)
  (if (<= n 0)
    'equal
    (if (null? l1)
      (if (null? l2)
        'equal
        'less)
      (if (null? l2)
        'greater
        (let ((result (compare (car l1) (car l2))))
          (if (eq? result 'equal)
            (list-compare-n compare (cdr l1) (cdr l2) (- n 1))
            result))))))

(define (list-compress test pred l)
  ;(list-compress! test pred (list-copy l)) ; naive implementation, but slower on average
  (if (null? l)
      '()
      (let ((l2 (cdr l)))
        (if (null? l2)
            (list (car l))
            (let ((e1 (car l))
                  (e2 (car l2)))
              (if (test e1 e2)
                  (list-compress test pred (cons (pred e1 e2) (cdr l2)))
                  (cons e1 (list-compress test pred l2))))))))

(define (list-compress! test pred l0)
  ;(debug 3 "list-compress!: l: " l)
  (unless (list-length<? l0 2)
    (let iter ((e1 (car l0))
               (e2 (second l0))
               (l l0))
      (cond ((test e1 e2)
             (let ((l2 (cddr l))
                   (combined (pred e1 e2)))
               (set-car! l combined)
               (set-cdr! l l2)
               (when (pair? l2)
                 (iter combined (car l2) l))))
            (else
              (let ((l2 (cdr l)))
                (unless (list-length<? l2 2)
                  (iter e2 (second l2) l2)))))))
  l0)

(define (list-length<? l n)
  (and (> n 0)
       (or (null? l)
           (list-length<? (cdr l) (- n 1)))))

(define list-length>? (lambda (l n)
  (or (< n 0)
      (and (pair? l)
           (list-length>? (cdr l) (- n 1))))))

(define (list-length=? l n)
  (if (null? l)
    (= n 0)
    (and (> n 0) ; removed (pair? l) test
         (list-length=? (cdr l) (- n 1)))))

(define (list-modify! l position pred)
  (let ((l2 (list-tail l position)))
    (set-car! l2 (pred (car l2)))))

(define (list-prefix l n)
  (if (and (> n 0)
           (pair? l))
    (cons (car l) (list-prefix (cdr l) (- n 1)))
    '()))

(define (list-sorted? pred l)
  (or (null? l)
      (let iter ((x1 (car l)) ; Recursive version would not be tail-recursive, hence iterative named-let.
                 (l1 (cdr l)))
        (or (null? l1)
            (let ((x2 (car l1)))
              ;;(debug 3 "list-sorted?: testing: " x1 " and " x2)
              (and (pred x1 x2)
                   (iter x2 (cdr l1))))))))

(define (list-sublist l start end)
  (list-prefix (list-tail l start) (- end start))) ; list-tail does not copy, but list-prefix copies, so that the list-sublist result is fresh

(cond-expand ((or geiser (not (and chicken data-structures))) ;; incompatible with SLIME
(define (merge a b c)
  (if (or (pair? a)
          (null? a)) ; compare is last
    (merge-chicken a b c)
    (merge3 a b c))) ; compare is first
(define (merge-chicken a b less?)
  (merge3 (lambda (x y)
            (if (less? x y)
              'less
              'greater))
           a b))
)(else ; for SLIME:
(define _merge merge)
(define (merge a b c)
  (if (or (pair? a)
          (null? a))
    (_merge a b c)
    (merge3 a b c)))
))
(define (merge3 pred a b)
  (if (null? a)
    b
    (if (null? b)
      a
      (let loop ((a1 (car a))
                 (a (cdr a))
                 (b1 (car b))
                 (b (cdr b))
                 (result '()))
        ;(debug 3 "merge3: a: " a " b: " b " result: " result)
        (cond ((eq? (pred b1 a1) 'less)
               (cond ((null? b) ; b1 is less than a1
                      (cond ((pair? result)
                             (append-reverse! result (cons b1 (cons a1 a))))
                            (else
                              (cons b1 (cons a1 a)))))
                     (else
                       (loop a1 a (car b) (cdr b) (cons b1 result)))))
              (else
                (cond ((null? a) ; b1 is greater (or equal) a1
                       (cond ((pair? result)
                              (append-reverse! result (cons a1 (cons b1 b))))
                             (else
                               (cons a1 (cons b1 b)))))
                      (else
                        (loop (car a) (cdr a) b1 b (cons a1 result))))))))))

(define (merge-no-duplicates pred l1 l2)
  (let iter ((acc '()))
    (cond ((null? l1)
           (append-reverse! acc l2))
          ((null? l2)
           (append-reverse! acc l1))
          (else
            (let* ((x1 (car l1))
                   (x2 (car l2))
                   (com (pred x1 x2)))
              ;(debug 3 "merge-no-duplicates: x1: " x1 " x2: " x2)
              (case com
                ((less)
                 (set! l1 (cdr l1))
                 (iter (cons x1 acc)))
                ((greater)
                 (set! l2 (cdr l2))
                 (iter (cons x2 acc)))
                (else ;(equal)
                  ;(assrt (eq? com 'equal) "merge-no-duplicates: unexpected compare result for:" x1 x2)
                  (set! l1 (cdr l1))
                  (set! l2 (cdr l2))
                  (iter (cons x1 acc))))))))) ; keep the element from list l1

(define *custom-module-warning #f)
(define *custom-module-warning-port #f)

(define *custom-module-error #f)
(define *custom-module-error-port #f)

(define (module-error module . args)
  (if *custom-module-error
    (apply *custom-module-error module args)
    (apply standard-module-error module args)))

(define (standard-module-error module . arguments)
  (let ((p (or *custom-module-error-port
               (current-output-port))))
    (newline p)
    (wr-stream p "Error: in " module " module:")
    (for-each (lambda (a)
                (wr-stream p " " a))
              arguments)
    (newline p)
    (flush-output-port p)
    (error (string-append module " module") arguments ""))) ; to return to top level error handler in bigloo

(define (module-warning module . args)
  (if *custom-module-warning
    (apply *custom-module-warning module args)
    (apply standard-module-warning module args)))

(define (standard-module-warning module . arguments)
  (let ((p (or *custom-module-warning-port
               (current-output-port))))
    (wr-stream p "Warning: in " module " module:")
    (for-each
      (lambda (a)
        (wr-stream p " " a))
      arguments)
    (newline p)
    (flush-output-port p)
    #f))

(define (float->string f digits . maybe-decsep)
  (let-optionals* maybe-decsep ((decsep #\.))
    ;(debug 3 "float->string: f: " f " digits: " digits)
    (if (negative? f)
        (string-append "-" (float->string (abs f) digits decsep))
        (let* ((fact (exp-base 10 digits))
               (f-fix (inexact->exact (round (* f fact))))
               (integer-part (quotient f-fix fact))
               (fractional-part (modulo f-fix fact)))
          (if (< digits 1)
              (integer->string integer-part)
              (string-append (integer->string integer-part) (string decsep) (integer->string-pad fractional-part digits #\0)))))))

(define (number-compare a b)
  (if (< a b)
    'less
    (if (> a b)
      'greater
      'equal)))

(define (option-new . options)
  (cons 'dummy-option options))
; not working yet:
;(define-syntax option-new
;  (syntax-rules ()
;    ((option-new)
;     (list 'dummy-option))
;    ((option-new . options)
;     (cons 'dummy-option options))))

(define (option-on! options . o)
  (let ((o2 (filter-new (lambda (opt1)
                          (not (member opt1 options)))
                        o)))
    (when (pair? o2)
      ;(debug 3 "option-on!: effective added options: " o2 " to be added to: " options)
      (append! options o2)
      ;(assrt (list-length<? options 30) "unusually long option list" options) ; for error tracking only
      )
    o2))

(define *debug-flags (option-new))

(define (quotient-fix a b x)
  ;(debug 3 "quotient-fix: " a "/" b " * " x)
  (cond ((zero? b)
         (module-warning "general" "quotient-fix called with zero divisor" a b x)
         0)
        (else
          (quotient (+ (quotient (* a x 10) b) 5) 10))))

(cond-expand (bigloo
(define (read-lines-string input-stream)
  (read-lines input-stream))
)(else
(define (read-lines-string input-stream)
  (let iter ((result '())
             (line (read-line-string input-stream)))
    ;(debug 3 "read-lines-string: line: " line)
    (cond ((string? line)
            (iter (cons line result) (read-line-string input-stream)))
          (else ; (or (eof-object? line) (not line))
           (reverse! result)
           ;(reverse result)
           ))))
))
;\end{so}

(cond-expand (bigloo
(define (read-terms in) (port->sexp-list in))
)(chicken
(define (read-terms in) (read-list in))
)(gambit
(define (read-terms in) (read-all in))
)(else
(define (read-terms in)
  (let ((term (read in)))
    (if (eof-object? term)
        '()
        (let ((result (list term)))
          (let iter ((last result)
                     (term2 (read in)))
            ;(debug 3 "read-terms: " term2)
            (cond ((eof-object? term2)
                   result)
                  (else
                   (let ((last2 (list term2)))
                     (set-cdr! last last2)
                     (iter last2 (read in))))))))))
))
(define (reduce-r pred l)
  (let ((l1 (cdr l)))
    (if (null? l1)
      (car l)
      (pred (car l) (reduce-r pred l1)))))

(define (set-union compare a b)
  ;(debug 3 "set-union: a: " a " b: " b)
  ;(assrt (list-sorted? (lambda (x1 x2) (eq? (compare x1 x2) 'less)) a) "set-union: list 1 not sorted")
  ;(assrt (list-sorted? (lambda (x1 x2) (eq? (compare x1 x2) 'less)) b) "set-union: list 2 not sorted")
  (if (null? a)
      (list-copy b)
      (if (null? b)
          (list-copy a)
          ;(set-union2 compare a b (car a) (car b))
          (let ((acc (list 'dummy)))
            (set-union2/acc compare a b (car a) (car b) acc) ; tail-recursive
            (cdr acc)))))

(define (set-union2/acc compare a0 b0 a-element0 b-element0 acc0)
  ;(debug 3 "set-union2/acc: a: " a " b: " b)
  (let iter ((a a0)
             (b b0)
             (a-element a-element0)
             (b-element b-element0)
             (acc acc0))
    (case (compare a-element b-element)
      ((less)
       (let ((a1 (cdr a)))
         (if (null? a1)
             (set-cdr! acc (cons a-element (list-copy b)))
             (let ((acc2 (list a-element)))
               (set-cdr! acc acc2)
               (iter a1 b (car a1) b-element acc2)))))
      ((greater)
       (let ((b1 (cdr b)))
         (if (null? b1)
             (set-cdr! acc (cons b-element (list-copy a)))
             (let ((acc2 (list b-element)))
               (set-cdr! acc acc2)
               (iter a b1 a-element (car b1) acc2)))))
      (else ;(equal)
        (let ((a1 (cdr a))
              (b1 (cdr b)))
          (if (null? a1)
              (set-cdr! acc (cons a-element (list-copy b1)))
              (if (null? b1)
                  (set-cdr! acc (cons a-element (list-copy a1)))
                  (let ((acc2 (list a-element)))
                    (set-cdr! acc acc2)
                    (iter a1 b1 (car a1) (car b1) acc2)))))))))

(define (list-sort pred l)
  (if (null? l)
    '()
    (let-values (((l rest) (list-sort2 (length l) pred l)))
      l)))
    ;(cond ((debugging? 3)
    ;       (wr "list-sort: result: ") (newline) (for-each (lambda (x) (write-c x) (newline)) result)
    ;       (let ((l-length (length l))
    ;             (result-length (length result)))
    ;         (cond ((not (= l-length result-length))
    ;                (wr "Warning: unexpected length of sort result: " l-length " " result-length) (newline) (newline))))
    ;       ))

(define (list-sort2 n pred l)
  (case n
    ((1)
     (values (list (car l)) (cdr l)))
    ((2)
     (let ((l2 (cdr l)))
       (values (list-sort-two pred (car l) (car l2)) (cdr l2))))
    (else
      (let* ((n1 (quotient n 2))
             (n2 (- n n1)))
        (let-values (((result1 result1-rest) (list-sort2 n1 pred l)))
          (let-values (((result2 result2-rest) (list-sort2 n2 pred result1-rest)))
            (values (merge pred result1 result2) result2-rest)))))))

(define (list-sort-two pred a b)
  ;(debug 'ibl "list-sort-two: a: " a " b: " b)
  (if (eq? (pred a b) 'greater)
    (list b a)
    (list a b)))

(define (list-sort-no-duplicates pred l)
  ;(debug 3 "list-sort-no-duplicates: l: " l)
  (if (null? l)
    '()
    (car (list-sort-no-duplicates2 (length l) pred l))))

(define (list-sort-no-duplicates2 n pred l)
  (case n
    ((1)
     (list (list (car l)) (cdr l)))
    ((2)
     (list (list-sort-two-no-duplicates pred (car l) (cadr l)) (cddr l)))
    (else
      (let* ((n1 (quotient n 2))
             (n2 (- n n1))
             (result1 (list-sort-no-duplicates2 n1 pred l))
             (result2 (list-sort-no-duplicates2 n2 pred (cadr result1))))
        ;(debug 3 "list-sort-no-duplicates2: result1: " result1)
        ;(debug 3 "list-sort-no-duplicates2: result2: " result2)
        (list (merge-no-duplicates pred (car result1) (car result2))
              (cadr result2))))))

(define (list-sort-two-no-duplicates pred a b)
  ;(debug 3 "list-sort-two-no-duplicates: " a " " b)
  (case (pred a b)
        ((less)
         (list a b))
        ((greater)
         (list b a))
        (else
         (list a))))

(define (remp pred lis)
  (let recur ((lis lis))
    (if (null? lis)
      lis
      (let ((head (car lis))
            (tail (cdr lis)))
        (if (pred head)
          (recur tail)
          (let ((new-tail (recur tail)))
            (if (eq? tail new-tail)
              lis
              (cons head new-tail))))))))

(cond-expand (bigloo
(define (string-char-position s c . maybe-start)
  (let-optionals* maybe-start ((i 0))
    ;(string-char-index s c i)
    (string-char-index-ur s c i (- (string-length s) i))))
)(else
(define (string-char-position s c . maybe-start)
  (let-optionals* maybe-start ((i0 0))
    ;(debug 3 "string-char-position: s: " s " c: " c " maybe-start: " maybe-start)
    (let ((n (string-length s)))
      (let iter ((i i0))
        (and (< i n)
             (if (char=? (string-ref s i) c)
                 i
                 (iter (+ i 1))))))))
))
(cond-expand ((or bigloo chicken)
(define (string-compare a b)
  (let ((result (string-compare3 a b)))
    (if (< result 0)
      'less
      (if (> result 0)
        'greater
        'equal))))
)(else
(define (string-compare a b)
  ;(string-compare-pred char-compare a b)
  (if (string<? a b)
    'less
    (if (string=? a b)
      'equal
      'greater)))
))
(define (string-prefix s n)
  (substring s 0 n))

(define (string-tokenize1 sep-pred s . maybe-start+end)
  (if (string-null? s)
      '()
      (let-optionals* maybe-start+end ((start 0) (end (string-length s)))
        (let ((result '()))
          (for-integers-down
            (lambda (i)
              (when (sep-pred (string-ref s i))
                (set! result (cons (substring s (+ i 1) end) result))
                (set! end i)))
            start (- end 1))
          (cons (substring s start end) result)))))

(define (symbol-compare a b)
  (string-compare (symbol->string a) (symbol->string b)))

(define (union-map compare pred l . maybe-sorted?)
  (let-optionals* maybe-sorted? ((sorted? #f))
    (let ((result '()))
      (for-each
        (lambda (x)
          (let ((result2 (pred x)))
            ;(debug 3 "union-map: result2: " result2 " for: " x)
            (when (pair? result2)
              (unless sorted?
                ;(debug 3 "union-map: sorting ...")
                (set! result2 (list-sort-no-duplicates compare result2)))
              ;(set! result (set-union! compare result result2)) ; not tail-recursive due to set-union! and list-sort-no-duplicates
              (set! result (set-union compare result result2)))))
        l)
      result)))

(cond-expand (chicken ; bigloo3.7a, but not ok for utf-8
(define (wr . arguments)
  (for-each display arguments))
)(else
(define (wr . arguments)
  (for-each display-p arguments))))

(cond-expand (chicken
(define (wr-stream stream . arguments)
  (for-each (lambda (arg)
              (display arg stream))
            arguments))
)(else
(define (wr-stream stream . arguments)
  (for-each (lambda (arg)
              (display-p arg stream))
            arguments))
))
(define (wr-symbol s)
  (write s))

(define (wr-symbol-stream sym port)
  (write sym port))

(define (write-spaces n . maybe-port)
  (cond ((null? maybe-port)
         (do-n (lambda ()
                 (write-char #\space))
               n))
        (else
         (let ((port (car maybe-port)))
           (do-n (lambda ()
                   (write-char #\space port))
                 n)))))

(define (vector-map! pred v)
  (let ((n (vector-length v)))
    (do ((i 0 (+ i 1)))
        ((>= i n) v)
      (vector-set! v i (pred (vector-ref v i))))))
